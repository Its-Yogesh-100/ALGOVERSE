<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>JavaScript Binary Search Tree</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous" />


        <link rel="stylesheet" href="../../css/footer_code.css">
        <link rel="stylesheet" href="../../css/prism.css">
        <style>
            body {
                background-color: #282C34;
               
            }
            h1{
                color: white;
                text-align: center;
                font-size: 50px;
                margin-bottom: 50px;            }
        </style>
    </head>

<body>
   
        <div>
            <h1>
                <center> Binary Search Tree</center>
            </h1>
            <section>
                <div class="buttons-container bst-actions-container"></div>
            </section>
            <section>
                
                <div>
                    
                    <div class="tree">
                        <div class="node node--root"></div>
                    </div>
                </div>
            </section>
        </div>

<footer>
            <div id="description">
                <div class="code">
                    <div class="selectedPane">
                        <span>Code in Java</span>
                    </div>

                    <pre id="code_java" style="font-family: 'Poppins', sans-serif;
                    font-size: 15px;
                    letter-spacing: 3px;">


 <code class="language-java" style="font-size: 16px; font-weight: bold;">
<<<<<<< HEAD
  public class BinarySearchTree {  
  
    //Represent a node of binary tree  
    public static class Node{  
        int data;  
        Node left;  
        Node right;  
  
        public Node(int data){  
            //Assign data to the new node, set left and right children to null  
            this.data = data;  
            this.left = null;  
            this.right = null;  
        }  
      }  
  
      //Represent the root of binary tree  
      public Node root;  
  
      public BinarySearchTree(){  
          root = null;  
      }  
  
      //insert() will add new node to the binary search tree  
      public void insert(int data) {  
          //Create a new node  
          Node newNode = new Node(data);  
  
          //Check whether tree is empty  
          if(root == null){  
              root = newNode;  
              return;  
            }  
          else {  
              //current node point to root of the tree  
              Node current = root, parent = null;  
  
              while(true) {  
                  //parent keep track of the parent node of current node.  
                  parent = current;  
  
                  //If data is less than current's data, node will be inserted to the left of tree  
                  if(data < current.data) {  
                      current = current.left;  
                      if(current == null) {  
                          parent.left = newNode;  
                          return;  
                      }  
                  }  
                  //If data is greater than current's data, node will be inserted to the right of tree  
                  else {  
                      current = current.right;  
                      if(current == null) {  
                          parent.right = newNode;  
                          return;  
                      }  
                  }  
              }  
          }  
      }  
  
      //minNode() will find out the minimum node  
      public Node minNode(Node root) {  
          if (root.left != null)  
              return minNode(root.left);  
          else  
              return root;  
      }  
  
      //deleteNode() will delete the given node from the binary search tree  
      public Node deleteNode(Node node, int value) {  
          if(node == null){  
              return null;  
           }  
          else {  
              //value is less than node's data then, search the value in left subtree  
              if(value < node.data)  
                  node.left = deleteNode(node.left, value);  
  
              //value is greater than node's data then, search the value in right subtree  
              else if(value > node.data)  
                  node.right = deleteNode(node.right, value);  
  
              //If value is equal to node's data that is, we have found the node to be deleted  
              else {  
                  //If node to be deleted has no child then, set the node to null  
                  if(node.left == null && node.right == null)  
                      node = null;  
  
                  //If node to be deleted has only one right child  
                  else if(node.left == null) {  
                      node = node.right;  
                  }  
  
                  //If node to be deleted has only one left child  
                  else if(node.right == null) {  
                      node = node.left;  
                  }  
  
                  //If node to be deleted has two children node  
                  else {  
                      //then find the minimum node from right subtree  
                      Node temp = minNode(node.right);  
                      //Exchange the data between node and temp  
                      node.data = temp.data;  
                      //Delete the node duplicate node from right subtree  
                      node.right = deleteNode(node.right, temp.data);  
                  }  
              }  
              return node;  
          }  
      }  
  
      //inorder() will perform inorder traversal on binary search tree  
      public void inorderTraversal(Node node) {  
  
          //Check whether tree is empty  
          if(root == null){  
              System.out.println("Tree is empty");  
              return;  
           }  
          else {  
  
              if(node.left!= null)  
                  inorderTraversal(node.left);  
              System.out.print(node.data + " ");  
              if(node.right!= null)  
                  inorderTraversal(node.right);  
  
          }  
      }  
  
      public static void main(String[] args) {  
  
          BinarySearchTree bt = new BinarySearchTree();  
          //Add nodes to the binary tree  
          bt.insert(50);  
          bt.insert(30);  
          bt.insert(70);  
          bt.insert(60);  
          bt.insert(10);  
          bt.insert(90);  
  
          System.out.println("Binary search tree after insertion:");  
          //Displays the binary tree  
          bt.inorderTraversal(bt.root);  
  
          Node deletedNode = null;  
          //Deletes node 90 which has no child  
          deletedNode = bt.deleteNode(bt.root, 90);  
          System.out.println("\nBinary search tree after deleting node 90:");  
          bt.inorderTraversal(bt.root);  
  
          //Deletes node 30 which has one child  
          deletedNode = bt.deleteNode(bt.root, 30);  
          System.out.println("\nBinary search tree after deleting node 30:");  
          bt.inorderTraversal(bt.root);  
  
          //Deletes node 50 which has two children  
          deletedNode = bt.deleteNode(bt.root, 50);  
          System.out.println("\nBinary search tree after deleting node 50:");  
          bt.inorderTraversal(bt.root);  
      }  
}               
=======

    #include<bits/stdc++.h>
    using namespace std;
        
    int BinarySearch(int arr[],int size,int key)
    {
        int left=0;
        int right=size-1;
        int mid=left+(right-left)/2;
    
        while(left<=right){
    
            if(key==arr[mid]){
                 return mid;
            }
    
            else if(key>arr[mid])
            {
                left=mid+1;
            }
    
            else{
                right=mid-1;
            }
             mid=left+(right-left)/2;
        }
        return -1;
    }
    
    int main()
    {
    int arr[]={10,20,30,40,50,60};
    int size=sizeof(arr)/sizeof(arr[0]);
    
    int key=20;
    
    int k=BinarySearch(arr,size,key);
    
    <!-- cout<<k<<endl; -->
        
    return 0;
    }
                            
>>>>>>> a4f197f7ee1a047875e102bb6ae1900e9599fa15
</code>
 </pre>
                </div>

                <div class="complexity">
                    <div class="timeComplexity">
                        <div class="selectedPane">
                            <span>Time Complexity</span>
                        </div>
                        <pre id="time" style="font-family: 'Poppins', sans-serif;
                        font-size: 15px;
                        letter-spacing: 3px;">
                        <code class="language-java">
<<<<<<< HEAD
The time complexity for creating a tree is O(1) . The time complexity for searching, inserting or deleting a node depends on the height of the tree h
so the worst case is O(h)

=======

Search Operation (Average Case):

Balanced BST: O(log n)
Unbalanced BST (worst case, resembling a linked list): O(n)
Insertion Operation (Average Case):

Balanced BST: O(log n)
Unbalanced BST (worst case, resembling a linked list): O(n)
Deletion Operation (Average Case):

Balanced BST: O(log n)
Unbalanced BST (worst case, resembling a linked list): O(n)

>>>>>>> a4f197f7ee1a047875e102bb6ae1900e9599fa15
                            </code>
                        </pre>
                    </div>

                    <div class="spaceComplexity">
                        <div class="selectedPane">
                            <span>Space Complexity</span>
                        </div>
                        <pre id="space" style="font-family: 'Poppins', sans-serif;
                        font-size: 15px;
                        letter-spacing: 3px;">
<<<<<<< HEAD
                            <code class="language-java">The space complexity of searching a node in a BST 
                            would be O(n) with 'n' being the depth of the tree(number of nodes present in a tree)
=======
                            <code class="language-java">
Node Size: O(1) per node (assuming constant-size keys).
Number of Nodes: O(n) where 'n' is the number of nodes in the binary search tree.
>>>>>>> a4f197f7ee1a047875e102bb6ae1900e9599fa15
                            </code>
                        </pre>
                    </div>
                </div>
</footer>
    
<script src="../../js/prism.js"></script>

    <script defer="defer" src="../js_binary_search_tree/js_binary_search_tree.bundle.js"></script>
</body>

</html>