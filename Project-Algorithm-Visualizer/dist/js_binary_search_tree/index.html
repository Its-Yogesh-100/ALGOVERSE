<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>JavaScript Binary Search Tree</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.1/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-+0n0xVW2eSR5OomGNYDnhzAbDsOXxcvSN1TPprVMTNDbiYZCxYbOOl7+AMvyTG2x" crossorigin="anonymous" />


        <link rel="stylesheet" href="../../css/footer_code.css">
        <link rel="stylesheet" href="../../css/prism.css">
        <style>
            body {
                background-color: #282C34;
               
            }
            h1{
                color: white;
                text-align: center;
                font-size: 50px;
                margin-bottom: 50px;            }
        </style>
    </head>

<body>
   
        <div>
            <h1>
                <center> Binary Search Tree</center>
            </h1>
            <section>
                <div class="buttons-container bst-actions-container"></div>
            </section>
            <section>
                
                <div>
                    
                    <div class="tree">
                        <div class="node node--root"></div>
                    </div>
                </div>
            </section>
        </div>


        <footer>
            <div id="description">
                <div class="code">
                    <div class="selectedPane">
                        <span>Code in C++</span>
                    </div>
    
                    <pre id="code_java" style="font-family: 'Poppins', sans-serif;
                    font-size: 15px;
                    letter-spacing: 3px;">
    
    
    <code class="language-java" style="font-size: 16px; font-weight: bold;">

        #include< iostream >
            #include< queue >
            using namespace std;
            
            class node {
                public:
                    int data;
                    node* left;
                    node* right;
            
                node(int d) {
                    this -> data = d;
                    this -> left = NULL;
                    this -> right = NULL;
                }
            };
            
            node* buildTree(node* root) {
            
                cout << "Enter the data: " << endl;
                int data;
                cin >> data;
                root = new node(data);    
            
                if(data == -1) {
                    return NULL;
                }
            
                cout << "Enter data for inserting in left of " << data << endl;
                root->left = buildTree(root->left);
                cout << "Enter data for inserting in right of " << data << endl;
                root->right = buildTree(root->right);
                return root;
            
            }
            
            void levelOrderTraversal(node* root) {
                queue<node*> q;
                q.push(root);
                q.push(NULL);
            
                while(!q.empty()) {
                    node* temp = q.front();
                    q.pop();
            
                    if(temp == NULL) { 
                        //purana level complete traverse ho chuka hai
                        cout << endl;
                        if(!q.empty()) { 
                            //queue still has some child ndoes
                            q.push(NULL);
                        }  
                    }
                    else{
                        cout << temp -> data << " ";
                        if(temp ->left) {
                            q.push(temp ->left);
                        }
            
                        if(temp ->right) {
                            q.push(temp ->right);
                        }
                    }
                }
            
            }
            
            void inorder(node* root) {
                //base case
                if(root == NULL) {
                    return ;
                }
            
                inorder(root->left);
                cout << root-> data << " ";
                inorder(root->right);
            
            }
            
            void preorder(node* root) {
                //base case
                if(root == NULL) {
                    return ;
                }
            
                cout << root-> data << " ";
                preorder(root->left);
                preorder(root->right);
            
            }
            
            void postorder(node* root) {
                //base case
                if(root == NULL) {
                    return ;
                }
            
                postorder(root->left);
                postorder(root->right);
                cout << root-> data << " ";
            
            }
            
            void buildFromLevelOrder(node* &root) {
                queue< node*> q;
            
                cout << "Enter data for root" << endl;
                int data ;
                cin >> data;
                root = new node(data);
                
                q.push(root);
            
                while(!q.empty()) {
                    node* temp = q.front();
                    q.pop();
            
                    cout << "Enter left node for: " << temp->data << endl;
                    int leftData;
                    cin >> leftData;
            
                    if(leftData != -1) {
                        temp -> left = new node(leftData);
                        q.push(temp->left);
                    }
            
                    cout << "Enter right node for: " << temp->data << endl;
                    int rightData;
                    cin >> rightData;
            
                    if(rightData != -1) {
                        temp -> right = new node(rightData);
                        q.push(temp->right);
                    }
                }
             }
            
            
            int main() {
            
                node* root = NULL;
            
                buildFromLevelOrder(root);
                levelOrderTraversal(root);
                // 1 3 5 7 11 17 -1 -1 -1 -1 -1 -1 -1
            
                /*
                //creating a Tree
                root = buildTree(root);
                //1 3 7 -1 -1 11 -1 -1 5 17 -1 -1 -1 
                //level order
                cout << "Printing the level order tracersal output " << endl;
                levelOrderTraversal(root);
            
                cout << "inorder traversal is:  ";
                inorder(root); 
            
                cout << endl << "preorder traversal is:  ";
                preorder(root); 
            
                cout << endl << "postorder traversal is:  ";
                postorder(root); 
                */
            
            
                return 0;
            }
    
    
                            
    </code>
    </pre>
                </div>
    
                <div class="complexity">
                    <div class="timeComplexity">
                        <div class="selectedPane">
                            <span>Time Complexity</span>
                        </div>
                        <pre id="time" style="font-family: 'Poppins', sans-serif;
                        font-size: 15px;
                        letter-spacing: 3px;">
                        <code class="language-java">
                            **Time Complexity (for a binary search tree, BST, in balanced condition):**

                             **Search Operation:** O(log n) - Logarithmic time.

                             **Insertion Operation:** O(log n) - Logarithmic time.
                             
                             **Deletion Operation:** O(log n) - Logarithmic time.
                            
                           
                            </code>
                        </pre>
                    </div>
    
                    <div class="spaceComplexity">
                        <div class="selectedPane">
                            <span>Space Complexity</span>
                        </div>
                        <pre id="space" style="font-family: 'Poppins', sans-serif;
                        font-size: 15px;
                        letter-spacing: 3px;">
                            <code class="language-java">
                                **Space Complexity:**
                            
                                 **Node Size:** O(1) per node.

                                 **Number of Nodes:** O(n) where 'n' is the number of nodes in the BST.
                                 
                                 **Additional Overhead:** O(n) in the worst case, accounting for any balancing information or additional pointers.
                            </code>
                        </pre>
                    </div>
                </div>
    </footer>
    
    
<script src="../../js/prism.js"></script>

    <script defer="defer" src="../js_binary_search_tree/js_binary_search_tree.bundle.js"></script>
</body>

</html>